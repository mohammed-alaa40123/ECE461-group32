"use strict";exports.id=543,exports.ids=[543],exports.modules={83543:(t,e,r)=>{r.d(e,{hfs:()=>M});const s=new TextDecoder,i=new TextEncoder;class o extends Error{constructor(t){super(`Method "${t}" does not exist on impl.`)}}class n extends Error{constructor(t){super(`Method "${t}" is not supported on this impl.`)}}class a extends Error{constructor(){super("Implementation already set.")}}function l(t){if(!t||!(t instanceof URL)&&"string"!=typeof t)throw new TypeError("Path must be a non-empty string or URL.")}function h(t){if(!("string"==typeof t||t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("File contents must be a string, ArrayBuffer, or ArrayBuffer view.")}function c(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return i.encode(t);if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t)){const e=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);return new Uint8Array(e)}throw new TypeError("Invalid contents type. Expected string or ArrayBuffer.")}class p{type;data;timestamp=Date.now();constructor(t,e){this.type=t,this.data=e}}class f{#t;#e;#r=new Map;constructor({impl:t}){this.#t=t,this.#e=t}#s(t,...e){for(const r of this.#r.values())r.push(new p("call",{methodName:t,args:e}))}logStart(t){if(!t||"string"!=typeof t)throw new TypeError("Log name must be a non-empty string.");if(this.#r.has(t))throw new Error(`Log "${t}" already exists.`);this.#r.set(t,[])}logEnd(t){if(this.#r.has(t)){const e=this.#r.get(t);return this.#r.delete(t),e}throw new Error(`Log "${t}" does not exist.`)}isBaseImpl(){return this.#e===this.#t}setImpl(t){if(this.#s("implSet",t),this.#e!==this.#t)throw new a;this.#e=t}resetImpl(){this.#s("implReset"),this.#e=this.#t}#i(t){if("function"!=typeof this.#e[t])throw new o(t)}#o(t,e){if("function"!=typeof this.#e[t])throw new n(e)}#n(t,...e){return this.#s(t,...e),this.#i(t),this.#e[t](...e)}#a(t,...e){return this.#i(t),this.#e[t](...e)}#l(t,e,...r){return this.#s(e,...r),this.#o(t,e),this.#e[t](...r)}async text(t){l(t);const e=await this.#l("bytes","text",t);return e?s.decode(e):void 0}async json(t){l(t);const e=await this.#l("bytes","json",t);return e?JSON.parse(s.decode(e)):void 0}async arrayBuffer(t){l(t);const e=await this.#l("bytes","arrayBuffer",t);return e?.buffer}async bytes(t){return l(t),this.#n("bytes",t)}async write(t,e){l(t),h(e),this.#s("write",t,e);let r=c(e);return this.#a("write",t,r)}async append(t,e){l(t),h(e),this.#s("append",t,e);let r=c(e);return this.#a("append",t,r)}async isFile(t){return l(t),this.#n("isFile",t)}async isDirectory(t){return l(t),this.#n("isDirectory",t)}async createDirectory(t){return l(t),this.#n("createDirectory",t)}async delete(t){return l(t),this.#n("delete",t)}async deleteAll(t){return l(t),this.#n("deleteAll",t)}async*list(t){l(t),yield*await this.#n("list",t)}async*walk(t,{directoryFilter:e=()=>!0,entryFilter:r=()=>!0}={}){l(t),this.#s("walk",t,{directoryFilter:e,entryFilter:r});const s=async function*(t,{directoryFilter:e,entryFilter:r,parentPath:i="",depth:o=1}){for await(const n of this.#a("list",t)){const a={path:n.name,depth:o,...n};i&&(a.path=`${i}/${a.path}`);let l=r(a);if(l.then&&(l=await l),l&&(yield a),n.isDirectory){let i=e(a);if(i.then&&(i=await i),!i)continue;const l=t instanceof URL?new URL(n.name,t.href.endsWith("/")?t.href:`${t.href}/`):`${t.endsWith("/")?t:`${t}/`}${n.name}`;yield*s(l,{directoryFilter:e,entryFilter:r,parentPath:a.path,depth:o+1})}}}.bind(this);yield*s(t,{directoryFilter:e,entryFilter:r})}async size(t){return l(t),this.#n("size",t)}async lastModified(t){return l(t),this.#n("lastModified",t)}async copy(t,e){return l(t),l(e),this.#n("copy",t,e)}async copyAll(t,e){return l(t),l(e),this.#n("copyAll",t,e)}async move(t,e){return l(t),l(e),this.#n("move",t,e)}async moveAll(t,e){return l(t),l(e),this.#n("moveAll",t,e)}}Symbol.iterator,Error,Error,Error,Error;var u=r(76760);class m{id=Math.random().toString(36).slice(2);fn;error;timestamp=Date.now();lastAttempt=this.timestamp;resolve;reject;signal;constructor(t,e,r,s,i){this.fn=t,this.error=e,this.timestamp=Date.now(),this.lastAttempt=Date.now(),this.resolve=r,this.reject=s,this.signal=i}get age(){return Date.now()-this.timestamp}}class d{#h=[];#c;#p;#f;#u;constructor(t,{timeout:e=6e4,maxDelay:r=100}={}){if("function"!=typeof t)throw new Error("Missing function to check errors");this.#u=t,this.#c=e,this.#p=r}retry(t,{signal:e}={}){let r;e?.throwIfAborted();try{r=t()}catch(t){return Promise.reject(new Error(`Synchronous error: ${t.message}`,{cause:t}))}return r&&"function"==typeof r.then?Promise.resolve(r).catch((r=>{if(!this.#u(r))throw r;return new Promise(((s,i)=>{this.#h.push(new m(t,r,s,i,e)),e?.addEventListener("abort",(()=>{i(e.reason)})),this.#m()}))})):Promise.reject(new Error("Result is not a promise."))}#m(){clearTimeout(this.#f),this.#f=void 0;const t=this.#h.shift();if(!t)return;const e=()=>{this.#f=setTimeout((()=>this.#m()),0)};return function(t,e){return t.age>e}(t,this.#c)?(t.reject(t.error),void e()):function(t,e){const r=Date.now()-t.lastAttempt,s=Math.max(t.lastAttempt-t.timestamp,1);return r>=Math.min(1.2*s,e)}(t,this.#p)?(t.lastAttempt=Date.now(),void Promise.resolve(t.fn()).then((e=>t.resolve(e))).catch((e=>{this.#u(e)?(t.lastAttempt=Date.now(),this.#h.push(t)):t.reject(e)})).finally((()=>this.#m()))):(this.#h.push(t),void e())}}var y=r(51455),w=r(73136);const I=new Set(["ENFILE","EMFILE"]);class E{name;isFile;isDirectory;isSymlink;constructor(t){this.name=t.name,this.isFile=t.isFile(),this.isDirectory=t.isDirectory(),this.isSymlink=t.isSymbolicLink()}}class g{#d;#y;constructor({fsp:t=y}={}){this.#d=t,this.#y=new d((t=>I.has(t.code)))}bytes(t){return this.#y.retry((()=>this.#d.readFile(t))).then((t=>new Uint8Array(t.buffer))).catch((t=>{if("ENOENT"!==t.code)throw t}))}async write(t,e){const r=Buffer.from(e);return this.#y.retry((()=>this.#d.writeFile(t,r))).catch((e=>{if("ENOENT"===e.code){const e=u.dirname(t instanceof URL?(0,w.fileURLToPath)(t):t);return this.#d.mkdir(e,{recursive:!0}).then((()=>this.#d.writeFile(t,r)))}throw e}))}async append(t,e){const r=Buffer.from(e);return this.#y.retry((()=>this.#d.appendFile(t,r))).catch((e=>{if("ENOENT"===e.code){const e=u.dirname(t instanceof URL?(0,w.fileURLToPath)(t):t);return this.#d.mkdir(e,{recursive:!0}).then((()=>this.#d.appendFile(t,r)))}throw e}))}isFile(t){return this.#d.stat(t).then((t=>t.isFile())).catch((t=>{if("ENOENT"===t.code)return!1;throw t}))}isDirectory(t){return this.#d.stat(t).then((t=>t.isDirectory())).catch((t=>{if("ENOENT"===t.code)return!1;throw t}))}async createDirectory(t){await this.#d.mkdir(t,{recursive:!0})}delete(t){return this.#d.rm(t).then((()=>!0)).catch((e=>{if("ERR_FS_EISDIR"===e.code)return this.#d.rmdir(t).then((()=>!0));if("ENOENT"===e.code)return!1;throw e}))}deleteAll(t){return this.#d.rm(t,{recursive:!0}).then((()=>!0)).catch((t=>{if("ENOENT"===t.code)return!1;throw t}))}async*list(t){const e=await this.#d.readdir(t,{withFileTypes:!0});for(const t of e)yield new E(t)}size(t){return this.#d.stat(t).then((t=>t.size)).catch((t=>{if("ENOENT"!==t.code)throw t}))}lastModified(t){return this.#d.stat(t).then((t=>t.mtime)).catch((t=>{if("ENOENT"!==t.code)throw t}))}copy(t,e){return this.#d.copyFile(t,e)}async copyAll(t,e){if(await this.isFile(t))return this.copy(t,e);const r=t instanceof URL?(0,w.fileURLToPath)(t):t,s=e instanceof URL?(0,w.fileURLToPath)(e):e;await this.createDirectory(e);for await(const e of this.list(t)){const t=u.join(r,e.name),i=u.join(s,e.name);e.isDirectory?await this.copyAll(t,i):await this.copy(t,i)}}move(t,e){return this.#d.stat(t).then((r=>{if(r.isDirectory())throw new Error(`EISDIR: illegal operation on a directory, move '${t}' -> '${e}'`);return this.#d.rename(t,e)}))}async moveAll(t,e){return this.#d.rename(t,e)}}const M=new class extends f{constructor({fsp:t}={}){super({impl:new g({fsp:t})})}}}};