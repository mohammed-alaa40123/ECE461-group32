(()=>{"use strict";var e,t,n={705:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.generatePackageId=t.metricCalcFromUrlUsingNetScore=void 0;const a=n(713),o=n(23),s=n(166),i=r(n(982)),c=(0,o.getLogger)();t.metricCalcFromUrlUsingNetScore=async function(e){const t=await(0,a.getGithubRepoInfoFromUrl)(e);if(c.info("repoInfo:",t),null==t)return null;const n=await(0,s.calculateNetScore)(void 0,t);if(!n)return null;const r=n.NetScore,o=n.RampUp,i=n.Correctness,u=n.BusFactor,l=n.ResponsiveMaintainer,d=n.License;return{ID:"",NAME:t.repo,OWNER:t.owner,VERSION:"1.0.0",URL:t.url,NET_SCORE:r,RAMP_UP_SCORE:o,CORRECTNESS_SCORE:i,BUS_FACTOR_SCORE:u,RESPONSIVE_MAINTAINER_SCORE:l,LICENSE_SCORE:d,PULL_REQUESTS_SCORE:1,PINNED_DEPENDENCIES_SCORE:1}},t.generatePackageId=(e,t)=>{console.log(`Generating id for ${e}@${t}`);const n=i.default.randomBytes(8);let r=BigInt(`0x${n.toString("hex")}`);return r%=BigInt("9223372"),console.log(`Generated package id ${r.toString()} for ${e}@${t}`),r.toString()}},490:function(e,t,n){var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.handleGetTracks=t.handleGetPackageCost=t.handleGetPackageRating=t.handleSearchPackagesByRegEx=t.handleGetPackageHistoryByName=t.handleResetRegistry=t.handleListPackages=t.handleDeletePackage=t.handleUpdatePackage=t.handleRetrievePackage=t.handleCreatePackage=t.handleAuthenticate=void 0;const i=o(n(59)),c=n(139),u=n(748),l=n(521),d=n(705),p=n(23),g=s(n(650)),f=s(n(829)),m=s(n(486)),h=(0,p.getLogger)();t.handleAuthenticate=async e=>{const{User:t,Secret:n}=JSON.parse(e),{name:r,isAdmin:a}=t,{password:o}=n;if(!r||"boolean"!=typeof a||!o)return(0,u.sendResponse)(400,{message:"Missing fields in AuthenticationRequest"});try{const e=await(0,i.getUserByName)(r);if(!e)return(0,u.sendResponse)(401,{message:"Invalid user or password."});if(!await m.default.compare(o,e.password_hash))return(0,u.sendResponse)(401,{message:"Invalid user or password."});const t=f.default.sign({sub:e.id,name:e.name,isAdmin:e.isAdmin},process.env.JWT_SECRET,{expiresIn:process.env.JWT_EXPIRES_IN||"1h"});return(0,u.sendResponse)(200,{token:`bearer ${t}`})}catch(e){return console.error("Authentication Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleCreatePackage=async(e,t)=>{var r,a,o;const s=(await Promise.resolve().then(n.t.bind(n,229,23))).default;const l=JSON.parse(e),{metadata:p,data:f}=l,m=p.Name,y=p.Version,_=(0,d.generatePackageId)(m,y);if(!(p&&p.Name&&p.Version&&p.ID))return(0,u.sendResponse)(400,{message:"Missing required package metadata fields."});if(f.Content&&f.URL||!f.Content&&!f.URL)return(0,u.sendResponse)(400,{message:"Either Content or URL must be set, but not both."});try{let e;if(f.Content){h.info("createPackage request via zip upload");const t=f.Content;if(!t)return h.debug("Invalid base64-encoded data"),(0,u.sendResponse)(400,{error:"Invalid base64-encoded data"});const n=Buffer.from(atob(t),"binary"),s=new g.default(n).getEntries();let i,c=null;if(s.forEach((e=>{const t=e.entryName.split("/");console.log(t),2===t.length&&"package.json"===t[1]&&(c=e.getData().toString("utf8"))})),null==c)return console.log("Invalid package creation request: No package.json found in zip"),(0,u.sendResponse)(400,{error:"Invalid package creation request: No package.json found in zip"});if(i=JSON.parse(c),h.console(`repo url: ${null===(r=null==i?void 0:i.repository)||void 0===r?void 0:r.url}, name: ${i.name}, version: ${i.version}`),!(null===(a=null==i?void 0:i.repository)||void 0===a?void 0:a.url)||!i.name||!i.version)return(0,u.sendResponse)(400,{error:"Invalid package creation request: package.json must contain repository url, package name, and version"});const l=function(e){let t=null;const n=[/^git:\/\/([^/]+)\/([^/]+)\/([^/]+)\.git$/,/^git@([^:]+):([^/]+)\/([^/]+)\.git$/,/^ssh:\/\/git@([^/]+)\/([^/]+)\/([^/]+)\.git$/,/^https:\/\/([^/]+)\/([^/]+)\/([^/]+)(\.git)?$/];for(const r of n){const n=r.exec(e);if(n){t=`https://${n[1]}/${n[2]}/${n[3]}`;break}}if(!t)throw new Error(`Unrecognized Git URL format: ${e}`);return t}(null===(o=null==i?void 0:i.repository)||void 0===o?void 0:o.url);if(e=await(0,d.metricCalcFromUrlUsingNetScore)(l),console.log("info",e),!e)return console.error("No package info returned from URL:",l),(0,u.sendResponse)(400,{error:"Invalid package creation request: Could not get package info from URL"});if(e.ID=_,e.NAME=i.name,e.VERSION=i.version,e.URL=l,e.NET_SCORE<.5)return h.console("Invalid package creation request: Package cannot be uploaded due to disqualifying rating."),(0,u.sendResponse)(424,{error:"Invalid package creation request: Package cannot be uploaded due to disqualifying rating."})}else{if(!f.URL)return h.console("Invalid package creation request: Bad set of Content and URL"),(0,u.sendResponse)(400,{error:"Invalid package creation request: Bad set of Content and URL"});{if(h.console(`createPackage request via public ingest:${f.URL}`),e=await(0,d.metricCalcFromUrlUsingNetScore)(f.URL),!e)return console.log("info",e),console.error("No package info returned from URL:",f.URL),(0,u.sendResponse)(400,{error:"Invalid package creation request: Could not get package info from URL"});if(e.ID=_,e.NET_SCORE<.5)return h.console("Invalid package creation request: Package cannot be uploaded due to disqualifying rating."),(0,u.sendResponse)(424,{error:"Invalid package creation request: Package cannot be uploaded due to disqualifying rating."});const t=await s(`https://api.github.com/repos/${e.OWNER}/${e.NAME}/zipball/HEAD`,{headers:{Authorization:process.env.GITHUB_TOKEN || "",Accept:"application/vnd.github.v3+json"}});if(!t.ok)return h.console("Invalid package creation request: Could not get GitHub url for zip package download"),(0,u.sendResponse)(400,{error:"Invalid package creation request: Could not get GitHub url"});Buffer.from(await t.arrayBuffer())}}const t=await(0,i.createPackage)(p,f);f.Content&&await(0,c.uploadPackageContent)(p.ID,f.Content);const n="\n      INSERT INTO package_history (package_id, user_id, action)\n      VALUES ($1, $2, $3)\n    ";return await i.default.query(n,[p.ID,5445,"CREATE"]),(0,u.sendResponse)(201,t)}catch(e){return console.error("Create Package Error:",e),"23505"===e.code?(0,u.sendResponse)(409,{message:"Package exists already."}):(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleRetrievePackage=async(e,t)=>{let n;console.log("id",e);try{n=(0,l.authenticate)(t)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}try{const t="SELECT * FROM packages WHERE id = $1",r=await i.default.query(t,[e]);if(0===r.rows.length)return(0,u.sendResponse)(404,{message:"Package does not exist."});const a=r.rows[0];if(console.log(r.rows[0]),!a.id&&!a.url)try{const t=await(0,c.getPackageContent)(e);a.data.Content=t}catch(e){return console.error("S3 Retrieval Error:",e),(0,u.sendResponse)(500,{message:"Failed to retrieve package content."})}const o="\n      INSERT INTO package_history (package_id, user_id, action)\n      VALUES ($1, $2, $3)\n    ";return await i.default.query(o,[e,n.sub,"DOWNLOAD"]),(0,u.sendResponse)(200,a)}catch(e){return console.error("Retrieve Package Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleUpdatePackage=async(e,t,n)=>{let r;try{r=(0,l.authenticate)(n)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}const a=JSON.parse(t),{metadata:o,data:s}=a;if(o.ID!==e)return(0,u.sendResponse)(400,{message:"Metadata ID does not match the path ID."});try{const t=[],n=[];let a=1;s.Content?(t.push("content = $"+a++),n.push(s.Content)):s.URL&&(t.push("url = $"+a++),n.push(s.URL)),t.push("debloat = $"+a++),n.push(s.debloat||!1),s.JSProgram&&(t.push("js_program = $"+a++),n.push(s.JSProgram)),t.push("updated_at = NOW()");const o=`UPDATE packages SET ${t.join(", ")} WHERE id = $${a} RETURNING *`;n.push(e);const l=await i.default.query(o,n);if(0===l.rows.length)return(0,u.sendResponse)(404,{message:"Package does not exist."});const d=l.rows[0];s.Content&&await(0,c.uploadPackageContent)(e,s.Content);const p="\n      INSERT INTO package_history (package_id, user_id, action)\n      VALUES ($1, $2, $3)\n    ";return await i.default.query(p,[e,r.sub,"UPDATE"]),(0,u.sendResponse)(200,d)}catch(e){return console.error("Update Package Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleDeletePackage=async(e,t)=>{let n;try{n=(0,l.authenticate)(t)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}try{const t="DELETE FROM packages WHERE id = $1 RETURNING *",r=await i.default.query(t,[e]);if(0===r.rows.length)return(0,u.sendResponse)(404,{message:"Package does not exist."});r.rows[0].data.Content&&await(0,c.deletePackageContent)(e);const a="\n      INSERT INTO package_history (package_id, user_id, action)\n      VALUES ($1, $2, $3)\n    ";return await i.default.query(a,[e,n.sub,"DELETE"]),(0,u.sendResponse)(200,{message:"Package is deleted."})}catch(e){return console.error("Delete Package Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleListPackages=async(e,t,n)=>{const r=JSON.parse(e),a=n&&n.offset?parseInt(n.offset):0;if(!Array.isArray(r))return(0,u.sendResponse)(400,{message:"Request body must be an array of PackageQuery."});try{const e=[];for(const t of r){const{Name:n,Version:r}=t;if(!n)return(0,u.sendResponse)(400,{message:"PackageQuery must include Name."});let a="SELECT * FROM packages WHERE name ILIKE $1";const o=[`%${n}%`];r&&(a+=" AND version = $2",o.push(r));const s=await i.default.query(a,o);e.push(...s.rows)}const t=e.slice(a,a+10),n=a+10<e.length?a+10:null,o={};return null!==n&&(o.offset=n.toString()),{statusCode:200,headers:o,body:JSON.stringify(t)}}catch(e){return console.error("List Packages Error:",e),e.message.includes("too many")?(0,u.sendResponse)(413,{message:"Too many packages returned."}):(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleResetRegistry=async e=>{let t;try{if(t=(0,l.authenticate)(e),!t.isAdmin)return(0,u.sendResponse)(403,{message:"Admin privileges required."})}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}try{return await i.default.query("TRUNCATE TABLE packages CASCADE;"),await i.default.query("TRUNCATE TABLE package_history CASCADE;"),(0,u.sendResponse)(200,{message:"Registry is reset."})}catch(e){return console.error("Reset Registry Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleGetPackageHistoryByName=async(e,t)=>{let n;try{n=(0,l.authenticate)(t)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}try{const t="\n      SELECT ph.*, u.name as user_name, u.is_admin\n      FROM package_history ph\n      JOIN packages p ON ph.package_id = p.id\n      JOIN users u ON ph.user_id = u.id\n      WHERE p.name ILIKE $1\n      ORDER BY ph.date DESC\n    ",n=await i.default.query(t,[`%${e}%`]);if(0===n.rows.length)return(0,u.sendResponse)(404,{message:"No such package."});const r=n.rows.map((e=>({User:{name:e.user_name,isAdmin:e.is_admin},Date:e.date.toISOString(),PackageMetadata:{Name:e.name,Version:e.version,ID:e.package_id},Action:e.action})));return(0,u.sendResponse)(200,r)}catch(e){return console.error("Get Package History Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleSearchPackagesByRegEx=async(e,t)=>{let n;try{n=(0,l.authenticate)(t)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}const{RegEx:r}=JSON.parse(e);if(!r)return(0,u.sendResponse)(400,{message:"Missing RegEx field in PackageRegEx."});try{const e="\n      SELECT * FROM packages\n      WHERE name ~* $1 OR readme ~* $1\n    ",t=await i.default.query(e,[r]);if(0===t.rows.length)return(0,u.sendResponse)(404,{message:"No package found under this regex."});const n=t.rows.map((e=>({Version:e.version,Name:e.name,ID:e.id})));return(0,u.sendResponse)(200,n)}catch(e){return console.error("Search Packages Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleGetPackageRating=async(e,t)=>{let n;try{n=(0,l.authenticate)(t)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}try{const t="SELECT * FROM package_ratings WHERE package_id = $1",n=await i.default.query(t,[e]);if(0===n.rows.length)return(0,u.sendResponse)(500,{message:"The package rating system choked on at least one of the metrics."});const r=n.rows[0];return(0,u.sendResponse)(200,r)}catch(e){return console.error("Get Package Rating Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleGetPackageCost=async(e,t,n)=>{let r;try{r=(0,l.authenticate)(t)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}const a=n&&"true"===n.dependency;try{const t="\n      SELECT p.id, p.name, p.version, p.size_mb\n      FROM packages p\n      WHERE p.id = $1\n    ";if(0===(await i.default.query(t,[e])).rows.length)return(0,u.sendResponse)(404,{message:"Package does not exist."});const n={};let r=0;const o=[e],s=new Set;for(;o.length>0;){const e=o.pop();if(s.has(e))continue;s.add(e);const t="SELECT * FROM packages WHERE id = $1",c=await i.default.query(t,[e]);if(0===c.rows.length)continue;const u=c.rows[0];if(n[u.id]={standaloneCost:u.size_mb,totalCost:u.size_mb},r+=u.size_mb,a){const t="SELECT dependency_id FROM dependencies WHERE package_id = $1";(await i.default.query(t,[e])).rows.forEach((e=>{s.has(e.dependency_id)||(o.push(e.dependency_id),r+=e.size_mb)}))}}if(a){let e=0;for(const t in n)e+=n[t].standaloneCost||0,n[t].totalCost=e}else n[e].totalCost=n[e].standaloneCost||0;return(0,u.sendResponse)(200,n)}catch(e){return console.error("Get Package Cost Error:",e),(0,u.sendResponse)(500,{message:"Internal server error."})}},t.handleGetTracks=async e=>{let t;try{t=(0,l.authenticate)(e)}catch(e){return(0,u.sendResponse)(e.statusCode,{message:e.message})}try{const e="\n      SELECT t.track_name\n      FROM user_tracks ut\n      JOIN tracks t ON ut.track_id = t.id\n      WHERE ut.user_id = $1\n    ",n=(await i.default.query(e,[t.sub])).rows.map((e=>e.track_name));return(0,u.sendResponse)(200,{plannedTracks:n})}catch(e){return console.error("Get Tracks Error:",e),(0,u.sendResponse)(500,{message:"The system encountered an error while retrieving the student's track information."})}}},73:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.handler=void 0,r(n(818)).default.config();const a=n(490);t.handler=async e=>{const{httpMethod:t,path:n,pathParameters:r,queryStringParameters:o,headers:s,body:i}=e;try{if("/authenticate"===n&&"PUT"===t)return await(0,a.handleAuthenticate)(i||"{}");if("/packages"===n&&"POST"===t)return await(0,a.handleListPackages)(i||"[]",s,o||{});if("/reset"===n&&"DELETE"===t)return await(0,a.handleResetRegistry)(s);if("/package/byRegEx"===n&&"POST"===t)return await(0,a.handleSearchPackagesByRegEx)(i||"{}",s);if(n&&n.startsWith("/package/byName/")&&"GET"===t){const e=n.split("/").pop()||"";return await(0,a.handleGetPackageHistoryByName)(e,s)}if("/package"===n&&"POST"===t)return await(0,a.handleCreatePackage)(i||"{}",s);if(n&&n.startsWith("/package/")&&n.endsWith("/rate")&&"GET"===t){const e=n.split("/")[2];return await(0,a.handleGetPackageRating)(e,s)}if(n&&n.startsWith("/package/")&&n.endsWith("/cost")&&"GET"===t){const e=n.split("/")[2];return await(0,a.handleGetPackageCost)(e,s,o||{})}if(n&&n.startsWith("/package/")&&"GET"===t){const e=n.split("/")[2];return await(0,a.handleRetrievePackage)(e,s)}if(n&&n.startsWith("/package/")&&"PUT"===t){const e=n.split("/")[2];return await(0,a.handleUpdatePackage)(e,i||"{}",s)}if(n&&n.startsWith("/package/")&&"DELETE"===t){const e=n.split("/")[2];return await(0,a.handleDeletePackage)(e,s)}return"/tracks"===n&&"GET"===t?await(0,a.handleGetTracks)(s):{statusCode:404,body:JSON.stringify({message:"Endpoint not found."}),headers:{"Content-Type":"application/json"}}}catch(e){return console.error("Lambda Handler Error:",e),e.statusCode&&e.message?{statusCode:e.statusCode,body:JSON.stringify({message:e.message}),headers:{"Content-Type":"application/json"}}:{statusCode:500,body:JSON.stringify({message:"Internal server error."}),headers:{"Content-Type":"application/json"}}}}},481:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.GET_VALUES_FOR_CODE_REVIEW_METRIC=t.GET_VALUES_FOR_BUS_FACTOR=t.GET_VALUES_FOR_RESPONSIVE_MAINTAINER=t.GET_VALUES_FOR_RAMP_UP=t.GET_VALUES_FOR_LICENSE=t.graphqlClient=t.GraphQLClient=void 0;const a=r(n(938));n(469);class o{constructor(){this.endpoint=process.env.GITHUB_GRAPHQL_ENDPOINT||"https://api.github.com/graphql",this.token=process.env.GITHUB_TOKEN || ""}async request(e,t){try{return(await a.default.post(this.endpoint,{query:e,variables:t},{headers:{Authorization:`Bearer ${this.token}`,"Content-Type":"application/json"}})).data.data}catch(e){throw console.error("GraphQL request failed:",e),e}}}t.GraphQLClient=o,t.graphqlClient=new o,t.GET_VALUES_FOR_LICENSE="\n  query getLicenseInfo($repoOwner: String!, $repoName: String!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      licenseInfo {\n        key\n        name\n        spdxId\n        url\n      }\n    }\n  }\n",t.GET_VALUES_FOR_RAMP_UP='\n  query getForksAndPRs($repoOwner: String!, $repoName: String!, $firstForks: Int!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      forks(first: $firstForks) {\n        edges {\n          node {\n            owner {\n              login\n            }\n            createdAt\n            pullRequests(first: 1) {\n              nodes {\n                createdAt\n                author {\n                  login\n                }\n              }\n            }\n            issues(first: 1) {\n              nodes {\n                createdAt\n                author {\n                  login\n                }\n              }\n            }\n            refs(refPrefix: "refs/heads/", first: 1) {\n              nodes {\n                target {\n                  ... on Commit {\n                    history(first: 1) {\n                      edges {\n                        node {\n                          committedDate\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      object(expression: "HEAD:README.md") {\n        ... on Blob {\n          id\n        }\n      }\n      contributing: object(expression: "HEAD:CONTRIBUTING.md") {\n        ... on Blob {\n          id\n        }\n      }\n    }\n  }\n',t.GET_VALUES_FOR_RESPONSIVE_MAINTAINER="\n  query getRepoData($repoOwner: String!, $repoName: String!, $firstIssues: Int!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      issues(first: $firstIssues, states: CLOSED) {\n        edges {\n          node {\n            createdAt\n            closedAt\n          }\n        }\n      }\n      allIssues: issues {\n        totalCount\n      }\n      totalClosedIssues: issues(states: CLOSED) {\n        totalCount\n      }\n    }\n  }\n",t.GET_VALUES_FOR_BUS_FACTOR="\n  query getCommits($repoOwner: String!, $repoName: String!, $since: GitTimestamp!, $after: String) {\n    repository(owner: $repoOwner, name: $repoName) {\n      defaultBranchRef {\n        target {\n          ... on Commit {\n            history(since: $since, first: 100, after: $after) {\n              edges {\n                node {\n                  author {\n                    user {\n                      login\n                    }\n                  }\n                  committedDate\n                }\n              }\n              pageInfo {\n                endCursor\n                hasNextPage\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n",t.GET_VALUES_FOR_CODE_REVIEW_METRIC="\n  query GetPullRequests($repoOwner: String!, $repoName: String!, $after: String) {\n    repository(owner: $repoOwner, name: $repoName) {\n      pullRequests(first: 100, after: $after) {\n        edges {\n          node {\n            additions  # Total lines of code added in the pull request\n            reviews {\n              totalCount  # Number of reviews for the pull request\n            }\n          }\n        }\n        pageInfo {\n          endCursor  # Cursor for pagination\n          hasNextPage  # Boolean to check if more pages are available\n        }\n      }\n    }\n  }\n"},23:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.logTestResults=t.reinitializeLogger=t.getLogger=void 0;const a=r(n(124)),o=r(n(928)),s=n(943),i=n(317),c=n(460);n(469);let u=null;const l=()=>{const e=(()=>{switch(process.env.LOG_LEVEL){case"1":return"info";case"2":return"debug";default:return"silent"}})(),t=a.default.format.combine(a.default.format.timestamp({format:"DD/MM/YYYY HH:mm:ss"}),a.default.format.printf((({timestamp:e,level:t,message:n})=>("object"==typeof n&&(n=JSON.stringify(n,null,2)),`${e} [${t}]: ${n}`)))),n=process.env.LOG_FILE||"logs/log.txt";u=a.default.createLogger({level:e,format:t,transports:[new a.default.transports.File({filename:n})],silent:"silent"===e}),u.console=t=>{console.log(t),"info"!==e&&"debug"!==e||u.info(t)}};t.getLogger=()=>{if(!u&&(l(),!u))throw new Error("Unable to initialize logger");return u},t.reinitializeLogger=()=>{if(u=null,l(),!u)throw new Error("Unable to reinitialize logger")},t.logTestResults=async()=>{const e=(0,t.getLogger)(),n=o.default.dirname(__filename),r=(0,c.promisify)(i.exec);try{try{const{stdout:t,stderr:n}=await r("npx vitest run --coverage --coverage.reportsDirectory=./logCoverage1 --reporter=json --outputFile=logCoverage1/test-results.json");n&&e.debug(`Error running tests: ${n} ${t}`)}catch(t){e.debug(t)}const t=await(0,s.readFile)(o.default.resolve(n,"..","logCoverage1","test-results.json"),"utf-8"),a=JSON.parse(t),i=a.numTotalTests,c=a.numPassedTests,u=await(0,s.readFile)(o.default.resolve(n,"..","logCoverage1","coverage-summary.json"),"utf-8"),l=JSON.parse(u),d=parseInt(l.total.lines.pct);e.console(`Total: ${i}`),e.console(`Passed: ${c}`),e.console(`Coverage: ${d}%`),e.console(`${c}/${i} test cases passed. ${d}% line coverage achieved.`)}catch(t){throw e.debug(t),t}}},404:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateCodeReviewFractionMetric=void 0;const r=n(481),a=(0,n(23).getLogger)();t.calculateCodeReviewFractionMetric=async function(e,t){try{let n=!0,o=null,s=0,i=0;for(;n;){const a=(await r.graphqlClient.request(r.GET_VALUES_FOR_CODE_REVIEW_METRIC,{repoOwner:e,repoName:t,after:o})).repository.pullRequests;a.edges.forEach((({node:e})=>{s+=e.additions,e.reviews.totalCount>0&&(i+=e.additions)})),o=a.pageInfo.endCursor,n=a.pageInfo.hasNextPage}if(0===s)return 0;const c=i/s;return a.debug(`Code Review Fraction Metric for ${e}/${t}: ${c}`),c}catch(e){return a.info("Error calculating code review fraction metric:",e),0}}},624:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateBusFactorScore=void 0;const r=n(481),a=(0,n(23).getLogger)();t.calculateBusFactorScore=async function(e,t){try{const n=new Date((new Date).setMonth((new Date).getMonth()-30)).toISOString();let o=!0,s=null;const i=new Map;for(;o;){const a=(await r.graphqlClient.request(r.GET_VALUES_FOR_BUS_FACTOR,{repoOwner:e,repoName:t,since:n,after:s})).repository.defaultBranchRef.target.history;a.edges.forEach((({node:e})=>{var t;const n=null===(t=e.author.user)||void 0===t?void 0:t.login;n&&i.set(n,(i.get(n)||0)+1)})),s=a.pageInfo.endCursor,o=a.pageInfo.hasNextPage}const c=function(e){const t=Array.from(e.values());t.sort(((e,t)=>e-t));const n=t.length;if(0===n)return 0;const r=Math.floor(.9*n),a=t[Number(r)],o=t.filter((e=>e>=a)).length;return Math.min(1,Math.max(Math.round(.05*o*100)/100,0))}(i);return a.debug(`Bus factor score for ${e}/${t}: ${c}`),c}catch(e){return a.info("Error calculating bus factor score:",e),0}}},892:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateCorrectness=void 0;const r=n(249),a=(0,n(23).getLogger)();t.calculateCorrectness=async function(e,t){return e?await async function(e,t){try{const n=new r.ESLint({ignore:!1}),o=await n.lintFiles([`${e}/**/*.{js,ts,tsx}`]);let s=0,i=0;for(const e of o)s+=e.errorCount,i+=e.warningCount;if(0===t)return a.debug(`No lines of code found in ${e}`),0;const c=Math.max(0,Math.min(1,1-(2*s+i)/t));return a.debug(`ESLint errors: ${s}, warnings: ${i}, total lines: ${t}, final score: ${c} for ${e}`),c}catch(e){return a.info(`Failed to calculate ESLint score: ${e}`),0}}(e,t):(a.info("Could not calculate correctness score: No repository directory provided"),0)}},250:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.calculateLicenseScore=void 0;const a=n(481),o=n(23),s=r(n(928)),i=n(943),c=(0,o.getLogger)(),u=new Set(["MIT","Apache-2.0","ISC","BSD-2-Clause","BSD-3-Clause","0BSD","Academic Free License v3.0","AFL-3.0","Artistic License 2.0","Artistic-2.0","Boost Software License 1.0","BSL-1.0","BSD-4-Clause","BSD-3-Clause-Clear","Creative Commons license family","CC","Creative Commons Zero v1.0 Universal","CC0-1.0","Creative Commons Attribution 4.0","CC-BY-4.0","Creative Commons Attribution ShareAlike 4.0","CC-BY-SA-4.0","Do What The F*ck You Want To Public License","WTFPL","Educational Community License v2.0","ECL-2.0","Eclipse Public License 1.0","EPL-1.0","Eclipse Public License 2.0","EPL-2.0","European Union Public License 1.1","EUPL-1.1","GNU Affero General Public License v3.0","AGPL-3.0","GNU General Public License v2.0","GPL-2.0","GNU General Public License v3.0","GPL-3.0","GNU Lesser General Public License v2.1","LGPL-2.1","GNU Lesser General Public License v3.0","LGPL-3.0","LaTeX Project Public License v1.3c","LPPL-1.3c","Microsoft Public License","MS-PL","Mozilla Public License 2.0","MPL-2.0","Open Software License 3.0","OSL-3.0","PostgreSQL License","PostgreSQL","SIL Open Font License 1.1","OFL-1.1","University of Illinois/NCSA Open Source License","NCSA","The Unlicense","Zlib","zLib License"]);t.calculateLicenseScore=async function(e,t,n){return await async function(e,t){try{const n=(await a.graphqlClient.request(a.GET_VALUES_FOR_LICENSE,{repoOwner:e,repoName:t})).repository.licenseInfo.spdxId;return c.debug("restLicense: ",n),u.has(n)?n:null}catch(e){return c.info("Error retrieving license information:",e),null}}(e,t)?(c.info("License found in GraphQL"),1):n?await async function(e){try{const t=s.default.join(e,"README.md"),n=await(0,i.readFile)(t,"utf8");for(const e of u)if(new RegExp(`\\b${e}\\b`,"i").test(n))return e;return null}catch(e){return c.info(`README.md not found or could not be read: ${e}`),null}}(n)?(c.info("License found in README.md"),1):await async function(e){try{const t=s.default.join(e,"package.json"),n=await(0,i.readFile)(t,"utf8"),r=JSON.parse(n).license;return u.has(r)?r:null}catch(e){return c.info(`package.json not found or could not be read: ${e}`),null}}(n)?(c.info("License found in package.json"),1):(c.info("No license found"),0):(c.info("Could not calculate license score: No repository directory provided"),0)}},166:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateNetScore=void 0;const r=n(250),a=n(276),o=n(973),s=n(892),i=n(713),c=n(624),u=n(404),l=n(23),d=n(460),p=n(317),g=n(863),f=(0,l.getLogger)();async function m(e){const t=Date.now();try{const n=await e();return{score:n,latency:(Date.now()-t)/1e3}}catch(e){return f.info(`Error calculating score: ${e}`),{score:0,latency:(Date.now()-t)/1e3}}}t.calculateNetScore=async function(e,t){var n,l,h;let y=[];e?y=await(0,i.processURLs)(e):t&&(y=[{packageName:t.repo,owner:t.owner,url:t.url}]);for(const{packageName:e,owner:t,url:i}of y){const y=Date.now(),_=await(0,g.cloneRepo)(`https://github.com/${t}/${e}.git`,e);let R=0,E=0;if(_)try{const e=(0,d.promisify)(p.exec),{stdout:t}=await e(`npx cloc --json ${_}`),r=JSON.parse(t),a=(null===(n=r.JavaScript)||void 0===n?void 0:n.code)||0,o=(null===(l=r.TypeScript)||void 0===l?void 0:l.code)||0;R=a+o,E=(null===(h=r.SUM)||void 0===h?void 0:h.code)||0}catch(e){f.info(`Error calculating lines of code: ${e}`)}const[w,v,k,C,S,$]=await Promise.all([m((()=>(0,r.calculateLicenseScore)(t,e,_))),m((()=>(0,a.calculateRampUpScore)(t,e,_,E))),m((()=>(0,o.calculateResponsiveMaintainerScore)(t,e))),m((()=>(0,c.calculateBusFactorScore)(t,e))),m((()=>(0,s.calculateCorrectness)(_,R))),m((()=>(0,u.calculateCodeReviewFractionMetric)(t,e)))]),{score:L,latency:P}=w,{score:b,latency:N}=v,{score:O,latency:I}=k,{score:T,latency:F}=C,{score:U,latency:M}=S,{score:q,latency:A}=$,D=.25*L+.1*b+.15*O+.15*T+.25*U+.1*q,x=(Date.now()-y)/1e3;return f.console(JSON.stringify({URL:i.trim(),NetScore:parseFloat(D.toFixed(2)),NetScore_Latency:parseFloat(x.toFixed(3)),RampUp:parseFloat(b.toFixed(2)),RampUp_Latency:parseFloat(N.toFixed(3)),Correctness:parseFloat(U.toFixed(2)),Correctness_Latency:parseFloat(M.toFixed(3)),BusFactor:parseFloat(T.toFixed(2)),BusFactor_Latency:parseFloat(F.toFixed(3)),ResponsiveMaintainer:parseFloat(O.toFixed(2)),ResponsiveMaintainer_Latency:parseFloat(I.toFixed(3)),License:parseFloat(L.toFixed(2)),License_Latency:parseFloat(P.toFixed(3)),CodeReviewFraction:parseFloat(q.toFixed(2)),CodeReviewFraction_Latency:parseFloat(A.toFixed(3))})),{URL:i.trim(),NetScore:parseFloat(D.toFixed(2)),NetScore_Latency:parseFloat(x.toFixed(3)),RampUp:parseFloat(b.toFixed(2)),RampUp_Latency:parseFloat(N.toFixed(3)),Correctness:parseFloat(U.toFixed(2)),Correctness_Latency:parseFloat(M.toFixed(3)),BusFactor:parseFloat(T.toFixed(2)),BusFactor_Latency:parseFloat(F.toFixed(3)),ResponsiveMaintainer:parseFloat(O.toFixed(2)),ResponsiveMaintainer_Latency:parseFloat(I.toFixed(3)),License:parseFloat(L.toFixed(2)),License_Latency:parseFloat(P.toFixed(3)),CodeReviewFraction:parseFloat(q.toFixed(2)),CodeReviewFraction_Latency:parseFloat(A.toFixed(3))}}}},276:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateRampUpScore=void 0;const r=n(481),a=n(172),o=(0,n(23).getLogger)();t.calculateRampUpScore=async function(e,t,n,s,i=50){try{const c=await r.graphqlClient.request(r.GET_VALUES_FOR_RAMP_UP,{repoOwner:e,repoName:t,firstForks:i}),u=await async function(e){let t=0,n=0;return e.repository.forks.edges.forEach((({node:e})=>{const r=new Date(e.createdAt),o=e.pullRequests.nodes.length>0?new Date(e.pullRequests.nodes[0].createdAt):null,s=e.issues.nodes.length>0?new Date(e.issues.nodes[0].createdAt):null,i=[e.refs.nodes.length>0?new Date(e.refs.nodes[0].target.history.edges[0].node.committedDate):null,o,s].filter((e=>e&&e>=r)).filter(Boolean).reduce(((e,t)=>t&&(!e||t<e)?t:e),null);if(i){const e=(0,a.differenceInDays)(i,r);t+=e,n++}})),o.debug(`Total days: ${t}, Forks with activity: ${n}`),n>0?t/n:0}(c),l=await async function(e,t,n){const r=e.repository.object,a=e.repository.contributing;return r&&a?(o.debug(`Found README and CONTRIBUTING for repo ${t}/${n}`),1):r||a?(o.debug(`Found README or CONTRIBUTING for repo ${t}/${n}`),.9):(o.debug(`No README or CONTRIBUTING found for repo ${t}/${n}`),.8)}(c,e,t),d=n?await async function(e,t){try{return o.debug(`Lines of code: ${t}`),t<=5e3?7:t<=1e4?10:t<=5e4?14:t<=1e5?21:t<=5e5?30:t<=1e6?45:60}catch(e){o.info("Error calculating target time:",e)}return 21}(0,s):21,p=d/Math.log(1.05),g=Math.max(Math.exp(-(u-d)/p),.3),f=Math.min(1,g*l);return o.debug(`Parts of the Ramp Up score: Main part: ${g}, Constant: ${p}, Documentation Weight: ${l}, Target Time: ${d}`),o.debug(`Ramp Up score for ${e}/${t}: ${f}`),f}catch(e){return o.info("Error fetching forks and PRs:",e),0}}},973:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateResponsiveMaintainerScore=void 0;const r=n(481),a=n(172),o=(0,n(23).getLogger)();t.calculateResponsiveMaintainerScore=async function(e,t){try{const n=await r.graphqlClient.request(r.GET_VALUES_FOR_RESPONSIVE_MAINTAINER,{repoOwner:e,repoName:t,firstIssues:100}),s=function(e){if(0===e.length)return-1;const t=e.map((e=>{const t=new Date(e.node.createdAt),n=new Date(e.node.closedAt);return(0,a.differenceInDays)(n,t)}));t.sort(((e,t)=>e-t));const n=Math.floor(t.length/2);return t.length%2!=0?t[Number(n)]:(t[n-1]+t[Number(n)])/2}(n.repository.issues.edges);if(-1===s)return o.debug(`For repository ${e}/${t}, no issues found, assigning score 0.5`),.5;const i=0==s?1:Math.min(1,7/s),c=n.repository.allIssues.totalCount,u=n.repository.totalClosedIssues.totalCount/c,l=i*u;return o.debug(`Responsive maintainer score for ${e}/${t}: ${l} with median response time: ${s} days, closure rate: ${u}`),l}catch(e){return o.info("Error calculating responsive maintainer score:",e),0}}},713:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.getGithubRepoInfoFromUrl=t.processURLs=t.getGithubRepo=void 0;const a=r(n(943)),o=n(23),s=n(863),i=(0,o.getLogger)();async function c(e){const{default:t}=await Promise.resolve().then(n.t.bind(n,229,23)),r=e.trim(),a=/github\.com\/(?<owner>[^/]+)\/(?<packageName>[^/]+)/;return r.includes("npmjs.com")?async function(e,t,r){var a;i.info("Handling NPM URL");const o=e.match(t);if(!(null===(a=null==o?void 0:o.groups)||void 0===a?void 0:a.packageName))return null;const s=o.groups.packageName;try{const e=await async function(e,t){const r=(await Promise.resolve().then(n.t.bind(n,229,23))).default,a=await r(`https://registry.npmjs.org/${e}`),o=await a.json();if("object"!=typeof o||null===o||!("repository"in o)||"string"!=typeof o.repository.url)throw new Error("Invalid data format");let s=o.repository.url;return s=s.replace(/^git\+/,"").replace(/\.git$/,""),s.match(t)}(s,r);if(null==e?void 0:e.groups)return i.info(`RepoURL: ${e.input}`),i.info(`Owner: ${e.groups.owner}, Package: ${e.groups.packageName}`),{packageName:e.groups.packageName,owner:e.groups.owner}}catch(e){i.info(`Error fetching NPM package: ${e}`)}return null}(r,/npmjs\.com\/package\/(?<packageName>[^/]+)/,a):r.includes("github.com")?function(e,t){i.info("Handling GitHub URL");const n=e.match(t);return(null==n?void 0:n.groups)?{packageName:n.groups.packageName,owner:n.groups.owner}:(i.info("Invalid GitHub URL"),null)}(r,a):(i.info("Invalid URL"),null)}t.getGithubRepo=c,t.processURLs=async function(e){if(!(0,s.isValidFilePath)(e))return i.info("Invalid file path"),[];let t;try{t=await a.default.readFile(e,"utf-8")}catch(e){return i.info(`Error reading file: ${e}`),[]}if(!t)return i.info("Empty file"),[];const n=t.trim().split("\n"),r=[];for(const e of n){i.info(`Working with URL: ${e}`);const t=await c(e);t?r.push({...t,url:e}):i.info("Invalid URL")}return i.info(`Results: ${JSON.stringify(r)}`),r},t.getGithubRepoInfoFromUrl=async function(e){const t=await c(e);return t?{url:e,owner:t.owner,repo:t.packageName}:null}},863:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.validateGithubToken=t.isValidFilePath=t.cloneRepo=void 0;const a=n(807),o=r(n(928)),s=r(n(943)),i=n(23),c=n(481),u=(0,i.getLogger)();function l(e){const t=o.default.resolve(e);return o.default.isAbsolute(t)&&!e.includes("..")}t.cloneRepo=async function(e,t){if(!l(t))return u.info("Invalid file path"),null;const n=(0,a.simpleGit)(),r=o.default.resolve(__dirname,"..","repos",t);try{return await s.default.mkdir(r,{recursive:!0}),await n.clone(e,r),u.info(`Repository cloned to ${r}`),r}catch(e){return e.message.includes("already exists")?(u.info(`Repository already cloned to ${r}`),r):(u.info("Error cloning repository:",e),null)}},t.isValidFilePath=l,t.validateGithubToken=async()=>{const e=(0,i.getLogger)();try{if((await c.graphqlClient.request("\n    query {\n      viewer {\n        login\n      }\n    }\n  ")).viewer.login)return e.info("GitHub token is valid"),!0;e.info("GitHub token is invalid")}catch(t){e.info("Error validating GitHub token:",t)}return!1}},59:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.get_package_by_name=t.get_package_id_cost_query=t.get_package_id_rate_query=t.delete_package_id_query=t.reset_endpoint_query=t.package_or_package_id_update_endpoint_query=t.getPackagedatabyID=t.createPackage=t.getUserByName=void 0;const a=r(n(818)),o=n(449);a.default.config();const s=new o.Pool({host:"localhost",user:"postgres",password:"root",database:"postgres",port:parseInt("5432"),max:20,idleTimeoutMillis:3e4,connectionTimeoutMillis:2e3,ssl:"true"===process.env.USE_SSL&&{rejectUnauthorized:!1}});t.default=s,t.getUserByName=async e=>{const t=await s.query("SELECT * FROM users WHERE name = $1",[e]);return 0===t.rows.length?null:t.rows[0]},t.createPackage=async(e,t)=>{const n=[e.ID,e.Name,e.Version,t.Content||null,t.URL||null,t.debloat||!1,t.JSProgram||null];return(await s.query("\n    INSERT INTO packages (id, name, version, content, url, debloat, js_program)\n    VALUES ($1, $2, $3, $4, $5, $6, $7)\n    RETURNING *;\n  ",n)).rows[0]},t.getPackagedatabyID=async e=>{const t=await s.query("select name,version,id,filepath,url,debloat from packages as p where p.id=$1",[e]);return 0===t.rows.length?null:{metadata:{Name:t.rows[0],Version:t.rows[1],ID:t.rows[2]},data:{Content:"get the content of the file location",URL:t.rows[4],debloat:t.rows[5],JSProgram:"get the jsprog of the file location"}}},t.package_or_package_id_update_endpoint_query=async function(e,t,n,r,a,o,i,c,u,l,d,p,g,f){let m="insert into packages(id,name,version,content,url,debloat,js_program,created_at,updated_at) values($1,$2,$3,$4,$5,$6,$7,$8,$9);";await s.query(m,[e,t,n,r,a,o,c,p.toISOString(),g.toISOString()]);for(let t=0;t<l.length;t++)m="insert into dependencies(package_id,dependency_id) values ($1,$2);",await s.query(m,[e,l[t]]);m="insert into package_ratings(package_id,bus_factor,bus_factor_latency,correctness,correctness_latency,ramp_up,ramp_up_latency,responsive_maintainer,responsive_maintainer_latency,license_score,license_score_latency,good_pinning_practice,good_pinning_practice_latency,pull_request,pull_request_latency,net_score,net_score_latency)values($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17);",await s.query(m,[e,d[0],d[1],d[2],d[3],d[4],d[5],d[6],d[7],d[8],d[9],d[10],d[11],d[12],d[13],d[14],d[15]]),m=i?"insert into package_history(package_id,user_id,date,action) values($1,$2,CURRENT_TIMESTAMP,'CREATE');insert into cost(pkg_id,cost)values($1,$3);":"insert into package_history(package_id,user_id,date,action) values($1,$2,CURRENT_TIMESTAMP,'UPDATE');insert into cost(pkg_id,cost)values($1,$3);",await s.query(m,[e,f,u])},t.reset_endpoint_query=async function(){await s.query("delete from cost;delete from dependencies;delete from package_history;delete from package_ratings;delete from packages;delete from tracks;delete from user_tracks;delete from users;",[])},t.delete_package_id_query=async function(e){await s.query("delete from packages where id=$1;delete from cost where pkg_id=$1;delete from package_history where package_id=$1;delete from dependencies where package_id=$1;delete from package_ratings where package_id=$1;",[e])},t.get_package_id_rate_query=async function(e,t){let n="select * from package_ratings;",r=await s.query(n,[t]);if(0==r.rows.length)return null;const a={RampUp:r.rows[0],Correctness:r.rows[2],BusFactor:r.rows[3],ResponsiveMaintainer:r.rows[4],LicenseScore:r.rows[5],GoodPinningPractice:r.rows[6],PullRequest:r.rows[7],NetScore:r.rows[8],RampUpLatency:r.rows[9],CorrectnessLatency:r.rows[10],BusFactorLatency:r.rows[11],ResponsiveMaintainerLatency:r.rows[12],LicenseScoreLatency:r.rows[13],GoodPinningPracticeLatency:r.rows[14],PullRequestLatency:r.rows[15],NetScoreLatency:r.rows[16]};return n="insert into package_history(package_id,user_id,date,action) values($1,$2,CURRENT_TIMESTAMP,'CREATE');",await s.query(n,[t,e]),a},t.get_package_id_cost_query=async function(e){let t="select SUM(cost) from (select  package_id as pid,dependency_id as did from dependencies as d where d.package_id=$1 ) as t , cost as c where c.pkg_id=t.did group by t.pid;",n=await s.query(t,[e]);t="select cost from cost where pkg_id=$1;";let r=await s.query(t,[e]),a=n[0]+r[0];return{id:{standaloneCost:r[0],totalCost:a}}},t.get_package_by_name=async function(e){try{return(await s.query("SELECT u.name AS username,u.is_admin, p.name AS package_name, p.version, p.id AS package_id, h.action, h.date FROM package_history AS h INNER JOIN  packages AS p ON h.package_id = p.id INNER JOIN  users AS u ON h.user_id = u.id;",[e])).rows.map((e=>({User:{name:e.username,isAdmin:e.is_admin},Date:e.date,PackageMetadata:{Name:e.name,Version:e.version,ID:e.id},Action:e.action})))}catch(e){throw console.error("Error executing query",e),e}}},139:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.deletePackageContent=t.getPackageContent=t.uploadPackageContent=void 0;const a=new(r(n(496)).default.S3);t.uploadPackageContent=async(e,t)=>{const n={Bucket:process.env.S3_BUCKET,Key:`packages/${e}.zip`,Body:Buffer.from(t,"base64")};await a.putObject(n).promise()},t.getPackageContent=async e=>{const t={Bucket:process.env.S3_BUCKET,Key:`packages/${e}.zip`};return(await a.getObject(t).promise()).Body.toString("base64")},t.deletePackageContent=async e=>{const t={Bucket:process.env.S3_BUCKET,Key:`packages/${e}.zip`};await a.deleteObject(t).promise()}},521:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.authenticate=void 0;const a=r(n(829));t.authenticate=e=>{const t=e["X-Authorization"]||e["x-authorization"];if(!t)throw{statusCode:403,message:"Missing Authentication Token"};const n=t.split(" ");if(2!==n.length||"bearer"!==n[0].toLowerCase())throw{statusCode:403,message:"Invalid Authentication Token"};const r=n[1];try{return a.default.verify(r,process.env.JWT_SECRET)}catch(e){throw{statusCode:403,message:"Invalid Authentication Token"}}}},748:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sendResponse=void 0,t.sendResponse=(e,t)=>({statusCode:e,headers:{"Content-Type":"application/json"},body:JSON.stringify(t)})},650:e=>{e.exports=require("adm-zip")},496:e=>{e.exports=require("aws-sdk")},938:e=>{e.exports=require("axios")},486:e=>{e.exports=require("bcrypt")},172:e=>{e.exports=require("date-fns")},818:e=>{e.exports=require("dotenv")},469:e=>{e.exports=require("dotenv/config")},249:e=>{e.exports=require("eslint")},829:e=>{e.exports=require("jsonwebtoken")},229:e=>{e.exports=require("node-fetch")},449:e=>{e.exports=require("pg")},807:e=>{e.exports=require("simple-git")},460:e=>{e.exports=require("util")},124:e=>{e.exports=require("winston")},317:e=>{e.exports=require("child_process")},982:e=>{e.exports=require("crypto")},943:e=>{e.exports=require("fs/promises")},928:e=>{e.exports=require("path")}},r={};function a(e){var t=r[e];if(void 0!==t)return t.exports;var o=r[e]={exports:{}};return n[e].call(o.exports,o,o.exports,a),o.exports}t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,a.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var o=Object.create(null);a.r(o);var s={};e=e||[null,t({}),t([]),t(t)];for(var i=2&r&&n;"object"==typeof i&&!~e.indexOf(i);i=t(i))Object.getOwnPropertyNames(i).forEach((e=>s[e]=()=>n[e]));return s.default=()=>n,a.d(o,s),o},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o=a(73);module.exports=o})();